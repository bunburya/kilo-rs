use std::io::{Read, stdin, stdout, Write};
use std::os::fd::AsRawFd;
use std::process::exit;
use termios::{BRKINT, CS8, ECHO, ICANON, ICRNL, IEXTEN, INPCK, ISIG, ISTRIP, IXON, OPOST, TCSAFLUSH,
              tcsetattr, Termios, VMIN, VTIME};
use terminal_size::{Height, terminal_size, Width};
use crate::error::Error::{EscSeqParseError, IoError};

use crate::error::Result;

/// Check if a byte represents an ASCII control character.
pub(crate) fn is_control(b: u8) -> bool {
    b < 32 || b == 127
}

/// Return the character that is generated by holding Ctrl while pressing the given key
pub(crate) fn ctrl_key(k: u8) -> u8 {
    k & 0x1f
}

/// Print a message to stdout and exit with a 1 exit code. Does not disable raw mode in the
/// terminal.
pub(crate) fn die(err_msg: &str) {
    eprintln!("Error: {err_msg}");
    exit(1);
}

/// Data and methods to facilitate interaction with a terminal.
pub(crate) struct Terminal {
    original_termios: Termios,
}

impl Terminal {

    pub(crate) fn new() -> Result<Terminal> {
        let original_termios = Termios::from_fd(stdin().as_raw_fd())?;
        Ok(Terminal { original_termios })
    }

    /// Enable raw mode in the terminal.
    pub(crate) fn enable_raw_mode(&self) {
        let mut raw = self.original_termios.clone();
        raw.c_iflag &= !(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
        raw.c_oflag &= !(OPOST);
        raw.c_lflag &= !(ECHO | ICANON | IEXTEN | ISIG);
        raw.c_cflag |= CS8;
        raw.c_cc[VMIN] = 0;
        raw.c_cc[VTIME] = 1;

        tcsetattr(stdin().as_raw_fd(), TCSAFLUSH, &raw)
            .unwrap_or_else(|e| die(&e.to_string()));
    }

    /// Disable raw mode in the terminal, returning the terminal settings to how they were before
    /// enabling it.
    pub(crate) fn disable_raw_mode(&self) -> Result<()> {
        tcsetattr(stdin().as_raw_fd(), TCSAFLUSH, &self.original_termios)?;
        Ok(())
    }


    /// Read a single key press from terminal input and return it
    pub(crate) fn read_key(&self) -> Result<u8> {
        let mut chr: [u8; 1] = [0];

        loop {
            stdin().read(&mut chr)?;
            return Ok(chr[0])
        }

    }

    /// Read input from the terminal until the end of the input.
    pub(crate) fn read_keys(&self) -> Result<Vec<u8>> {
        let mut v: Vec<u8> = vec!();
        stdin().read_to_end(&mut v)?;
        Ok(v)
    }

    pub(crate) fn read_keys_to_str(&self) -> Result<String> {
        let keys = self.read_keys()?;
        let string = String::from_utf8(keys)?;
        Ok(string)
    }

    pub(crate) fn clean_up(&self) -> Result<()> {
        self.disable_raw_mode()?;
        self.clear_screen()?;
        self.reset_cursor()
    }

    /// Disable raw mode in the terminal, print a message to stdout and exit with a 1 exit code.
    pub(crate) fn die_cleanly(&self, err_msg: &str) -> Result<()> {
        self.clean_up()?;
        Ok(die(err_msg))
    }

    /// Disable raw mode and exit with a success exit code.
    pub(crate) fn clean_exit(&self) -> Result<()> {
        self.clean_up()?;
        exit(0)
    }

    /// Write the given bytes to standard output. Does not flush to screen.
    pub(crate) fn write(&self, buf: &[u8]) -> Result<usize> {
        match stdout().write(buf) {
            Ok(value) => Ok(value),
            Err(e) => Err(IoError(e))
        }
    }

    /// Write the given bytes to standard output and immediately flush the buffer.
    pub(crate) fn write_flush(&self, buf: &[u8]) -> Result<usize> {
        let written = self.write(buf)?;
        self.flush()?;
        Ok(written)
    }

    /// Write the given string to standard output. Does not flush to screen.
    pub(crate) fn write_str(&self, s: &str) -> Result<usize> {
        self.write(s.as_bytes())
    }

    /// Write the given string to standard output and immediately flush the buffer.
    pub(crate) fn write_str_flush(&self, s: &str) -> Result<usize> {
        self.write_flush(s.as_bytes())
    }

    pub(crate) fn flush(&self) -> Result<()> {
        match stdout().flush() {
            Ok(value) => Ok(value),
            Err(e) => Err(IoError(e))
        }
    }

    /// Write an escape sequence to clear the screen.
    pub(crate) fn clear_screen(&self) -> Result<()> {
        self.write(b"\x1b[2J")?;
        Ok(())
    }

    /// Print an escape sequence to move the cursor to the given row and column.
    pub(crate) fn move_cursor_to(&self, row: usize, col: usize) -> Result<()> {
        self.write_str(&format!("\x1b[{row};{col}H"))?;
        Ok(())
    }

    /// Print an escape sequence to move the cursor forward by the given number of columns.
    pub(crate) fn move_cursor_forward(&self, cols: usize) -> Result<()> {
        self.write_str(&format!("\x1b[{cols}C"))?;
        Ok(())
    }

    /// Print an escape sequence to move the cursor down by the given number of rows.
    pub(crate) fn move_cursor_down(&self, rows: usize) -> Result<()> {
        self.write_str(&format!("\x1b[{rows}B"))?;
        Ok(())
    }

    pub(crate) fn hide_cursor(&self) -> Result<()> {
        self.write(b"\x1b[?25l")?;
        Ok(())
    }

    pub(crate) fn show_cursor(&self) -> Result<()> {
        self.write(b"\x1b[?25h")?;
        Ok(())
    }

    /// Print an escape sequence to query the cursor position, and return the result as a tuple of
    /// (row, col).
    pub(crate) fn get_cursor_position(&self) -> Result<(usize, usize)> {
        self.write_flush(b"\x1b[6n")?;
        let resp = self.read_keys_to_str()?;
        if !(resp.starts_with("\x1b[") && resp.ends_with('R')) {
            return Err(EscSeqParseError(resp));
        }
        let sep = match resp.chars().position(|c| c == ';') {
            Some(i) => i,
            None => return Err(EscSeqParseError(resp))
        };

        let rows = resp[2..sep].parse::<usize>();
        let cols = resp[(sep+1)..(resp.len()-1)].parse::<usize>();
        match (rows, cols) {
            (Ok(r), Ok(c)) => Ok((r, c)),
            _ => Err(EscSeqParseError(resp))
        }
    }

    /// Write an escape sequence to move the cursor to the top left corner.
    pub(crate) fn reset_cursor(&self) -> Result<()> {
        self.write(b"\x1b[;H")?;
        Ok(())
    }

    /// Return the screen size, as a tuple of (rows, cols)
    pub(crate) fn screen_size(&self) -> Result<(usize, usize)> {
        if let Some((Width(w), Height(h))) = terminal_size() {
            return Ok((h as usize, w as usize));
        }
        self.move_cursor_forward(999)?;
        self.move_cursor_down(999)?;
        self.get_cursor_position()
    }

}